# Case Study: Regression {#sec-cs-regression}


```{r results='hide', message=FALSE, warning=FALSE}
library(tidyverse)
library(HDSinRdata)
library(glmnet)
library(pROC)

```

# Prepare data

```{r}
data(tb_diagnosis)

tb_southafrica <- tb_diagnosis %>%
  filter(country == "South Africa") %>%
  select(-country) %>%
  na.omit()

tb_uganda <- tb_diagnosis %>%
  filter(country == "Uganda") %>%
  select(-country) %>%
  na.omit()

# train/test split
train_index <- sample(1:nrow(tb_southafrica), 
                      0.70*nrow(tb_southafrica), replace = FALSE)

tb_train <- tb_southafrica[train_index,]
tb_test <- tb_southafrica[-train_index,]

```

# Fit models

```{r}
# full model 
mod_full <- glm(tb ~ ., data = tb_train, family = binomial)
summary(mod_full)
```

```{r}
# backward selection
mod_step <- step(mod_full, direction = "backward")
summary(mod_step)
```


```{r}
# Lasso
X_train <- tb_train[,-1] %>% as.matrix
y_train <- tb_train[,1]
mod_lasso <- cv.glmnet(X_train, y_train, alpha = 1, family = "binomial")

coef(mod_lasso)
```
# Evaluate models on training set

```{r}
# Plot ROC curve

# Full model
roc_train_full <- roc(predictor = predict(mod_full),
                     response = tb_train$tb,
                     levels = c(0,1), direction = "<")

plot(roc_train_full, print.auc = TRUE, print.thres = TRUE)

# Backwards selection
roc_train_step <- roc(predictor = predict(mod_step),
                     response = tb_train$tb,
                     levels = c(0,1), direction = "<")

plot(roc_train_step, print.auc = TRUE, print.thres = TRUE)

# Lasso
roc_train_lasso <- roc(predictor = predict(mod_lasso, newx = X_train),
                     response = y_train,
                     levels = c(0,1), direction = "<")

plot(roc_train_lasso, print.auc = TRUE, print.thres = TRUE)

```

```{r, warning = FALSE}
# Calibration plot function
plot_calibration <- function(pred_probs, observed_y, num_cuts = 10) {
  
  calib_data <-  data.frame(prob = pred_probs,
                          bin = cut(pred_probs, breaks = num_cuts),
                          class = observed_y)
  calib_data <- calib_data %>% 
             group_by(bin) %>% 
             summarize(observed = sum(class)/n(), 
                       expected = sum(prob)/n(), 
                       se = sqrt(observed*(1-observed)/n()))
  
  plt <- ggplot(calib_data) + 
  geom_abline(intercept = 0, slope = 1, color="red") + 
  geom_errorbar(aes(x = expected, ymin=observed-1.96*se, 
                    ymax=observed+1.96*se), 
                colour="black", width=.01)+
  geom_point(aes(x = expected, y = observed)) +
  labs(x="Expected Proportion", y="Observed Proportion") +
  theme_minimal()
  
  return(plt)
  
}

plot_calibration(predict(mod_full, type = "response"), as.numeric(as.character(tb_train$tb)))
plot_calibration(predict(mod_step, type = "response"), as.numeric(as.character(tb_train$tb)))
plot_calibration(predict(mod_lasso, newx = X_train, type = "response")[,1], as.numeric(as.character(tb_train$tb)))

```


# Evaluate models on withheld test set 


```{r}
# Plot ROC curve

# Full model
roc_test_full <- roc(predictor = predict(mod_full, tb_test),
                     response = tb_test$tb,
                     levels = c(0,1), direction = "<")

plot(roc_test_full, print.auc = TRUE, print.thres = TRUE)

# Backwards selection
roc_test_step <- roc(predictor = predict(mod_step, tb_test),
                     response = tb_test$tb,
                     levels = c(0,1), direction = "<")

plot(roc_test_step, print.auc = TRUE, print.thres = TRUE)

# Lasso
X_test <- tb_test[,-1] %>% as.matrix
roc_test_lasso <- roc(predictor = predict(mod_lasso, newx = X_test),
                     response = tb_test$tb,
                     levels = c(0,1), direction = "<")

plot(roc_test_lasso, print.auc = TRUE, print.thres = TRUE)

```
```{r}
# Calibration plots

plot_calibration(predict(mod_full, tb_test, type = "response"), as.numeric(as.character(tb_test$tb)))
plot_calibration(predict(mod_step, tb_test, type = "response"), as.numeric(as.character(tb_test$tb)))
plot_calibration(predict(mod_lasso, newx = X_test, type = "response")[,1], as.numeric(as.character(tb_test$tb)))

```

# Evaluate models on different population


```{r}
# Plot ROC curve

# Full model
roc_val_full <- roc(predictor = predict(mod_full, tb_uganda),
                     response = tb_uganda$tb,
                     levels = c(0,1), direction = "<")

plot(roc_val_full, print.auc = TRUE, print.thres = TRUE)

# Backwards selection
roc_val_step <- roc(predictor = predict(mod_step, tb_uganda),
                     response = tb_uganda$tb,
                     levels = c(0,1), direction = "<")

plot(roc_val_step, print.auc = TRUE, print.thres = TRUE)

# Lasso
X_val <- tb_uganda[,-1] %>% as.matrix
roc_val_lasso <- roc(predictor = predict(mod_lasso, newx = X_val),
                     response = tb_uganda$tb,
                     levels = c(0,1), direction = "<")

plot(roc_val_lasso, print.auc = TRUE, print.thres = TRUE)

```


```{r}
# Calibration plots

plot_calibration(predict(mod_full, tb_uganda, type = "response"), as.numeric(as.character(tb_uganda$tb)))
plot_calibration(predict(mod_step, tb_uganda, type = "response"), as.numeric(as.character(tb_uganda$tb)))
plot_calibration(predict(mod_lasso, newx = X_val, type = "response")[,1], as.numeric(as.character(tb_uganda$tb)))

```

